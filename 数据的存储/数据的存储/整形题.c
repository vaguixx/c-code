#define _CRT_SECURE_NO_WARNINGS 1
#pragma warning(disable:6031)
#include<stdio.h>

//int main()
//{
//	char a = -1;
//	signed char b = -1;
//	unsigned char c = -1;
//	printf("a=%d  b=%d  c=%d\n", a, b, c);
//	return 0;
// }
	//我们知道，整形在内存中是以补码的形式存在的，正数的补码为原码，负数的补码需要运算
	//a   11111111111111111111111111111111(补码)
	//因为a为字符型，只有1个字节，8个二进制位,取后8位
	//a    11111111，因为char为signed char 所以，第一位为符号位
	// 再将补码换算成原码显示  a    11111110(反码)     10000001(原码)，故char a 里面存储的是-1
	// 
	// 
	// 
	//b    11111111111111111111111111111111(补码)
	// 因为b为char型，取后八位，且b为signed char
	//b    11111111,b有符号位，b   11111110(反码)     10000001(原码)，故char b里面存储的是-1
	// 
	// 
	// unsigned char c  =-1   ,
	// c  11111111111111111111111111111111（补码）
	// 取后八位 c 11111111
	//因为c为无符号char 默认c为正数，正数原反补一样，c =11111111（二进制）= 128



//#include<stdio.h>
//
//int main()
//{
//	char a = -128;
//	printf("%u\n", a);
//	//首先char a 可以理解为 signed char a 即有符号字符型c
//	// a   10000000000000000000000010000000(原码)
//	// a   11111111111111111111111101111111(反)
//	// a   11111111111111111111111110000000(补)
//	//因为是char a 取后八位  10000000
//	//%u == unsigned int ,把char类型转换成int型，即整形提升，往前补符号位
//	//a 11111111111111111111111110000000(补码)
//	//但是这个时候 是unsigned int ,即忽略符号位，那么补码 = 原码
//	//a   11111111111111111111111110000000(原码)
//	//a    4294967168
// 	return 0;
//}



//#include<stdio.h>
//
//int main()
//{
//	int i = -20;
//	//i -20   原码 10000000000000000000000000010100
//	//           反码 11111111111111111111111111101011
//	//           补码 11111111111111111111111111101100
//	unsigned int j = 10;
//	//           补码 11111111111111111111111111101100
//	//j 10 原反补 00000000000000000000000000001010
//	//i+j              11111111111111111111111111110110(补码)
//	//                   11111111111111111111111111110101（反码）
//	//                   10000000000000000000000000001010（原码）
//	printf("%d", i + j);
//	//故i+j= -10；               
//	return 0;
//}


//#include<stdio.h>
//
//int main()
//{
//	unsigned int i ;//无符号数>=0;死循环
//	for (i = 9; i >= 0; i--)
//	{
//		printf("%u\n", i);
//	}
//	//i 9   00000000000000000000000000001001(原反补)
//	//  8   00000000000000000000000000001000
//	//        ...
//	//        00000000000000000000000000000001
//	return 0;
//}


//#include<stdio.h>
//#include<string.h>
//int main()
//{
//	char a[1000];
//	int i;
//	for (i = 0; i < 1000; i++)
//	{
//		a[i] = -1 - i;//char，里面最多8个二进制位，
//		//i 的值为-1  -2  -3 ...... -128  ->127 126 125 ......1 0；
//
//	}
//	printf("%d", strlen(a));
//	//strlen求字符串长度的基本原理是找到‘\0','\0'的acsii码值为0，即找到0终止，所以
//	//strlen = 128 +127 =255
//	return 0;
//}


#include<stdio.h>
#include<string.h>

unsigned char i = 0;
int main()
{
	for (i = 0; i <=255; i++)
	{
		printf("hello world\n");//0 1 2 128,127...126....1 0 
	}
	
	return 0;
}